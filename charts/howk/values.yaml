# Default values for HOWK.
# Reference: Benchmarked at ~500 RPS with these defaults.

# External Dependencies (REQUIRED)
# HOWK requires Redis and Kafka to be provided externally.
# Install them separately before deploying HOWK.
#
# Quick start (Bitnami charts):
#   helm install redis oci://registry-1.docker.io/bitnamicharts/redis --set auth.enabled=false
#   helm install kafka oci://registry-1.docker.io/bitnamicharts/kafka --set replicaCount=1
#
# Or use Redpanda for simpler Kafka:
#   helm install redpanda redpanda/redpanda --set statefulset.replicas=1
#
externalServices:
  redis:
    addr: "redis-master:6379"   # Redis host:port
    password: ""                 # Redis password (if auth enabled)
    db: 0
  
  kafka:
    brokers:
      - "kafka:9092"            # Kafka broker list

# Image configuration
images:
  api:
    repository: renatocron/howk-api
    tag: v0.1.0
    pullPolicy: IfNotPresent
  worker:
    repository: renatocron/howk-worker
    tag: v0.1.0
    pullPolicy: IfNotPresent
  scheduler:
    repository: renatocron/howk-scheduler
    tag: v0.1.0
    pullPolicy: IfNotPresent
  reconciler:
    repository: renatocron/howk-reconciler
    tag: v0.1.0
    pullPolicy: IfNotPresent

# API Service
api:
  replicaCount: 1
  
  service:
    type: ClusterIP
    port: 8080
    # nodePort: 30080  # Uncomment for NodePort
  
  resources:
    requests:
      memory: "64Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"
  
  livenessProbe:
    path: /health
    initialDelaySeconds: 10
    periodSeconds: 10
  
  readinessProbe:
    path: /ready
    initialDelaySeconds: 5
    periodSeconds: 5
  
  ingress:
    enabled: false
    # hosts:
    #   - host: howk.example.com

# Worker
worker:
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "200m"
    limits:
      memory: "512Mi"
      cpu: "1000m"

# Scheduler
scheduler:
  enabled: true
  replicaCount: 1
  resources:
    requests:
      memory: "64Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"

# Reconciler
reconciler:
  enabled: true
  replicaCount: 1
  resources:
    requests:
      memory: "64Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"

# HOWK Configuration
config:
  api:
    port: 8080
    readTimeout: "10s"
    writeTimeout: "10s"
    maxRequestSize: 1048576  # 1MB

  kafka:
    topics:
      pending: howk.pending
      results: howk.results
      deadletter: howk.deadletter
      scripts: howk.scripts
      slow: howk.slow
      state: howk.state
    consumerGroup: howk-workers
    retention: "168h"
    producerBatchSize: 32768   # 32KB batches
    producerLingerMs: 50       # 50ms batching
    producerCompression: snappy
    consumerFetchMinBytes: 1
    consumerFetchMaxWait: "500ms"
    # PerKeyParallelism controls how many goroutines process messages for the same
    # partition key (ConfigID) concurrently. Default: 1 (sequential).
    # Higher values trade per-key ordering for throughput.
    perKeyParallelism: 1

  redis:
    poolSize: 100
    minIdleConns: 10
    dialTimeout: "5s"
    readTimeout: "3s"
    writeTimeout: "3s"

  delivery:
    timeout: "30s"
    maxIdleConns: 100
    maxConnsPerHost: 10

  retry:
    baseDelay: "10s"
    maxDelay: "24h"
    maxAttempts: 20
    jitter: 0.2

  circuitBreaker:
    failureThreshold: 5
    failureWindow: "60s"
    recoveryTimeout: "5m"
    probeInterval: "60s"
    successThreshold: 2

  scheduler:
    pollInterval: "1s"
    batchSize: 500
    lockTimeout: "30s"

  concurrency:
    maxInflightPerEndpoint: 50
    inflightTTL: "60s"
    slowLaneRate: 20
    # MaxInflightPerDomain is the default max concurrent requests to any single domain.
    # 0 = disabled (no domain-level limiting). Aggregates across all endpoint URLs on same host.
    maxInflightPerDomain: 0
    # DomainOverrides maps specific domains to custom concurrency limits.
    # Example: {"api.stripe.com": 200, "hooks.slack.com": 30}
    domainOverrides: {}

  ttl:
    circuitStateTTL: "24h"
    statusTTL: "168h"
    statsTTL: "48h"
    idempotencyTTL: "24h"
    retryDataTTL: "48h"

  lua:
    enabled: false
    timeout: "500ms"
    memoryLimitMb: 50

  # Prometheus metrics endpoint
  metrics:
    enabled: true
    port: 9090

  # Transformer (incoming webhook fan-out)
  transformer:
    enabled: false
    scriptDirs:
      - "/etc/howk/transformers"
    passwdDirs: []  # Empty = use scriptDirs
    timeout: "500ms"
    memoryLimitMb: 50

# Transformer scripts (ConfigMap-based)
# Each key becomes a .lua file, value is the script content
transformerScripts:
  # example-echo: |
  #   local data = json.decode(incoming)
  #   howk.post("https://httpbin.org/post", data)

# Transformer JSON configs (optional, per script)
# Each key becomes a .json file
transformerConfigs: {}
  # example-echo: |
  #   {"allowed_domains": ["httpbin.org"]}

# Transformer authentication (optional, per script)
# Each key becomes a .passwd file
transformerAuth: {}
  # example-echo: |
  #   admin:$2b$12$xxxxxxxx...

# ConfigMap reload configuration
# When enabled, a sidecar watches for ConfigMap changes and sends SIGHUP to reload scripts
# without pod restart. Requires shareProcessNamespace: true
configmapReload:
  enabled: false
  image:
    repository: ghcr.io/kiwigrid/k8s-sidecar
    tag: 1.25.2
    pullPolicy: IfNotPresent
  resources:
    limits:
      cpu: "100m"
      memory: "128Mi"
    requests:
      cpu: "10m"
      memory: "32Mi"
  # Reload behavior
  # Method 1: "signal" - Send SIGHUP to main process (requires shareProcessNamespace)
  # Method 2: "annotation" - Trigger rolling restart via annotation change
  method: annotation
  # For method: signal - the signal to send (1 = SIGHUP)
  signal: 1
  # Polling interval for watching ConfigMaps (seconds)
  sleepTime: 15

# Optional: Image pull secrets for private registries
global:
  imagePullSecrets: []
  # - name: regcred

# Service account
serviceAccount:
  create: true

# Node placement
nodeSelector: {}
tolerations: []
affinity: {}
